Программа Parallel-SAT для решения SAT-задач
                 
В режиме прогнозирования у КНФ статусы:
0 - WAIT
1 - STOPPED
2 - UNSAT
3 - SAT
                 
Ключи:
 -poly_mod - определение способа построения полиномов для прогнозирования
  = 0 отсекающая функция строитсся "классически" - с возрастанием по экспоненте (2^x)
  = 1 отсекающая функция строится как полином
  = 2 так же как при poly_mod == 1, но с назначением улучшения текущего 
	  прогнозного на основании не всех посчитанных SAT-задач из выборки)

Подробности реализации.
- При считывании из DIMACS в литералы: -x = x*2 + 1, x = x*2
  т.е. 1 -> 2, -1 -> 3, 2 -> 4, -2 -> 5, ...  
0. // full_mask; // полная маска, единичными битами помечены литералы, которые 
					передаются в solver_solve как известные
   // part_mask; // частичная маска, единичные биты соответствуют литералам, которые 
					переданы солверу как известные
   // values;    // значения литералов, указанных в part_mask
   Формат передаваемых масок: виесто одного unsigned long long int передается массив 
   из 7 unsigned int, чтобы иожно было выбирать не только из 64-ех первых переменных,
   а из 192 первых. 0-ой элемент - маска 6-ти элементов.
   пример: full_mask[0] = 3, значит переменные могут быть выбраны только из
   первых 64-ех.
1. При прогнозировании может оказаться, что часть КНФ из выборки еще не встало на счет,
а часть - уже посчиталось или считается, т.е. не для всех КНФ есть время счета.
Тогда строится прогноз, исходя из того, что время счета КНФ, не вставших на счет,
равно 0. При этом может оказаться, что даже при таких значениях всю выборку надо останавливать,
т.е. те, которые считаются, считаются слишком долго. Тогда счет тех КНФ из выборки, 
которые считаются, надо остановить, а КНФ, которые еще не счет не встали, надо пропускать,
т.е. не отправлять их на счет.
2. Лучшему текущиу прогнозу (cur_best_time) не может соответствовать набор, 
в котором есть еще не решенные SAT-задачи (этот прогноз может использоваться только
для возможного обрывания вычисления) (см. 1).
3. Пока на управляющем узле делается прогноз, составляется и отправляется список 
SAT-задач для остановки, на вычислительном узле может уже решится SAT-задача, сообщение
о остановке которой было отправлено от управляющего. На вычислительном узле это
проверяется (if ( current_task_index == -1 )), такое стоп-сообщение пропускается,
далее принимается все как обычно
4. останавливаем, только если превышение текущего прогнозного (а оно есть, если хотя бы 1 набор всеь отрешался,
скорее всего на правой границе)
5. Прерванная SAT-задача не должна помечаться как UNSAT

Варианты автоматического прогнозирования
deep_predict
1 и 2 - генерация точек с разным расстоянием Хэмминга от текущей (перебор не всей окрестности)
3 - быстрый переход к новой точке, если она лучше
4 - проверка всей окрестности, переход к лучшей точке из окрестности
	- запоминание точек, вся окрестность которых проверена
5 - быстрый переход к новой точке, если она лучше или по имитации отжига
6 - быстрый переход к лучшей точке из окрестности,
	tabu search:
	- запоминание точек, вся окрестность которых проверена
	- запоминание точек, часть окрестности которых проверена
	
TODO
// адаптировать работу при schema_type == rslos_end для нового считывания assumptions из файла
// Разбить точки в L2 на классы по числу единиц в векторе-центре (для каждого класса - список индексов)
	чтобы быстрее добавлять новую точку в L2
// Исправить несоответствие суммарного числа проверенных и остановленных точек числу L1.size() + L2.size() 
// Выделить прерыватель избыточных вычислений в отдельный процесс, чтобы успеть прерывать больше
// SimpSolver
// В режиме прогнозирования отправлять part_mask только когда начинается новая выборка
// Не запускать ReadCNF в режиме решения

Version 0.96 08.11.2013
[*] MAX_DISTANCE_TO_RECORD changed from 20 to 10
[+] added evaluation of predictions via propagation
[*] resizing of dummy_vec only if needed in MakeAssignsFromMasks()
[+] Added RECOMMEND_BATCH_VAR_COUNT = 16. MAX_BATCH_VAR_COUNT changed to 31
[*] Fixed counting numbers of problems solved on preprocessing in solving mode
[*] VS 2010 -> VS 2012

Версия 0.95 от 04.09.2013
[*] Исправлен расчет s^2. Вычислялась и для прерванных КНФ, но надо только для рельно решенных
[*] koef_val изменено с 8 на 16 для более равномерной нагрузки
[*] Исправлена ошибка в GetPredcit() - если в семействе не было решено ни одной задачи, его обработка не прерывалась
[*] Вывод итогового времени перемещен в solving_info. Вывод в файл "outout" убран.
[*] MAX_BATCH_VAR_COUNT изменена с 20 на 18 для лучшей масштибируемости - чем больше заданий, тем равномернее нагрузка
[-] Убрана рассылка стоп-сообщений в конце каждой итерации прогнозирования в режиме "Первая стадия".
	В этом режиме нужно решить все задачи, поэтому стоп-сообщения не нужны.
[*] Исправлена ошибка вычисления max_time_sample в GetPredict() - не учитывалось время незавршенных КНФ
[*] Ускорена процедура AddNewUncheckedArea(). Оставлена проверка только тех точек из L1 и L2,
	в которых число единиц близко к числу единиц добавляемой точки (необходимое условие нахождения в радиусе)
[+] Добавлено удаление точек из L1 и L2, которые дальше чем на MAX_DISTANCE_TO_RECORD_L2 от рекорда
[*] Значение по умолчанию deep_predict изменено с 0 на 6
[*] Значение по умолчанию cnf_in_set_count изменено с 0 на 100
[*] FULL_MASK_LEN изменено с 7 до 26. MAX_ASSIGNS_COUNT и MAX_CORE_LEN изменено с 192 до 800

Версия 0.94 от 23.08.2013
[+] Добавлен подсчет и вывод более одного выполняющего набора
[*] Добавлена константа MAX_BATCH_VAR_COUNT = 20 для предотвращения ошибки переполнения памяти 
	из-за слишком больших пачек заданий
[+] Добавлена универсальная возможность считывания assumptions из файла.
	Раньше работала только при schema_type == rslos_end

Версия 0.93 от 29.07.2013
[-] исходники minisat2-2 (старая версия с minisat.se), inttypes.h и stdint.h убраны из проекта
[*] тип solved_problems_count изменен с unsignend на unsigned long long
[+] Добавлено высчитывание среднего временя решения подзадач в режиме решения
[*] В режиме решения экземпляр minisat теперь создается 1 раз на каждом выч. процессе,
	для работы в incremental режиме

Версия 0.92 от 18.07.2013
[*] В режиме решения убрана чистка clearDB() после каждого запуска minisat. Привело к ускорению
[*] В ControlProcessPredict() после конца итерации может остаться IsRestartNeeded == true, что приводило
	к обрыванию следующей итерации. Сделан дополнительный быстрый выход в NewRecordPoint(), а также 
	проверка в DeepPredictMain()
[*] MIN_SOLVE_TIME изменено с 0.000002 на 0.000001
[+] В прогнозировании core_len присваивается значение predict_to, т.е. core_len не должно отличаться

Версия 0.91 от 17.07.2013
[+] Добавлен выбор случайного класса мощности дек. мн-в в L2 (чтобы равновероятно уйти вниз,
	вширь или вверх). В выбранном классе точка выбирается случайно.
[*] Исправлен вывод сообщения "Checked area with Hamming distance " при каждом обновлении рекорда
[*] Убрана остановка прогнозирования при нахождении SAT
[-] Убран вывод добавляемых в L2 векторов
[+] В ComputeProcessPredict() добавлено считывание КНФ в Solver один раз, дальше как в режиме решения -
	после обработки очищается база: S->clearDB()
[+] В minisat добавлен вывод информации о ходе решения только если не определен _MPI
[+] Добавлен параметр max_solving_time - максимальное допустимое время (в секундах) решения SAT задачи
[+] Добавлен вывод основной информации о ходе решения в файл solving_info. В нем временя решения
	заданий разбито по группам
[+] Добавлено инеративное решение задач с помощью minisat 2.2, с очисткой cleardb() после каждой итерации 
[*] Изменена структура папок
[+] В настройки прокета добавлен макрос _MPI

Версия 0.89 от 03.05.2013
[*] minisat 2.2 -> 2.2.1 (Jan 2013)

Версия 0.88 от 25.03.2013
[+] Доблавен порог max_L2_hamming_distance - максимальное расстояние на котором может быть очередная точка
	из L2. По умолчанию 2.
[*] Начальное значение predict_every_sec изменено на 2
[+] Остановка расчетов дек. мн-ва не прерывается если max_time_sample < MIN_STOP_TIME. Сделано т.к. приблизительное время
	для выборок с очень простыми задачами показывало слишком большое время. Из-за этого прерывались все расчеты, на которых
	срабатывал GetPredict().
[*] Убран избычтоный массив cnf_final_time_arr, в cnf_status_arr тип изменен с int на char. cnf_to_stop_arr расширается по требованию. 
	Память сократилась для 17 млн. заданий с 760 mb до 580
[*] part_mask теперь генерируется один для одного дек. мн-ва. Значения assumptions теперь генерируются на выч. процессах
	До - 3.2 гб для 177 дек. мн-в по 100 тыс в каждом (17 млн. заданий). После - 760 mb. Время на подготовку заданий сократилось
	примерно в 100 раз.

Версия 0.87 от 23.03.2013
[*] Испавлено частое срабатывание GetPredict() - теперь проверяется что за 1 значение делимое на PREDICT_EVERY_SEC
	будет 1 срабатывание
[+] Добавлена определние начального этапа поиска - он заканчивается когда мощность дек. мн-ва очередного рекорда больше предыдущего.
[*] Исправлена работа функции ControlProcessPredict(). Теперь GetPredict() происходит периодически независимо
	от наличия сообщений с процессов.

Версия 0.86 от 19.03.2013
[*] В WritePredictToFile() исправлен вывод информации о непроверенных множествах 
[*] Исправлен вывод инфомрации при deep_predict == 6
[+] Добавлен вывод в файл graph данных last_predict_record_time и current_predict_time
[*] bitset177 изменен на boost::dynamic_bitset<>

Версия 0.85 от 08.02.2013
[*] Если стартовое дек. мн-во больше чем ядровое (core_len < predict_to), то устанавливается core_len = predict_to
[*] Изменена функция MakeRandArr - теперь через boost'овый генератор Вихрь Мерсенна
[-] в масках убран байт [1] - для количества ненулевых значений подряд
[-] В MakeRandArr() убрана проверка на уникальность генерируемых чисел, т.к. тормозила
[*] Исправлено считывание известного дек. множества из файла
[*] Дек. множества - теперь не с 0 а с 1

Версия 0.84 от 30.01.2013
[*] FULL_MASK_LEN изменен с 34 на 8, для bivium хватит. А вообще надо перейти на dynamic_bitset из boost 
[*] Исправлен онлайн вывод min, max, mid и s^2 в WritePredictToFile() 
[-] В DeepPredictMain() убрано перемещение точки из L2 в L1, т.к. это уже делается при проверке окрестности
[+] Добавлен minisat2.2
[-] Убран minisat2 и PBsolver

Версия 0.83 от 18.01.2013
[+] Добавлен режим Tabu search с обработкой списков проверенных (L1) и неполностью проверенных (L2) окрестностей

Версия 0.82 от 12.01.2013
[+] Добавлен подсчет sample_variance - квадрата среднеквадратичного отклонения (s^2)
[*] Исправлен вывод минимального и максимального заначения в функции WritePredictToFile()
[*] Исправлена генерация случайных чисел в функции MakeRandArr(). До этого генерировались
2-байтные числа, теперь 8-байтные (через умножение 4 2-байтных).
[*] указатели -> векторы
[-] Убран режим MassPredict 
[-] Убран polynom_mode - ограничение прогнозной функции полиномами
[+] Добавлена проверка для точек из новых областей, если прогноз уже был посчитан, он не повторяется. 
	Для этого хранятся все "хорошие" точки, и вычисляется S хэмминга до каждой.
	
Версия 0.81 от 23.12.2012
[*] Значение proc_count по умолчанию изменено с 127 на 1, чтобы оценивать прогнозное время на 1 ядре.
[*] solved_cnf_count_arr теперь обновляется постоянно, а не в конце обработки выборки
[*] испрвален подсчет минимального значения в выборке
[*] var_choose_arr. vector вместо static int array

Версия 0.80 от 26.11.12
[+] Добавлено вычисление прогнозного значения в начальной точке.

Версия 0.79 от 19.10.12
[+] Добавлен режим deep_predict==5. Это локальный поиск с перебором всей окрестности радиуса 1. Если в этой окрестности 
не нашлось ничего лучше, радиус расширяется до 2. Если и там нет ничего лучше, поиск завершается.
[+] Добавлены счетчкики количества проверяемых точек и количества прерванных из них.
[*] В GetPredict() исправлены действия при статусе множества == 1 (STOPPED). Теперь дополнительных действий для него нет.
[+] Из файла считывается теперь и cur_temperature известной точки
[*] Порядок перебора точек в окрестностях сделан случайным, чтобы уравновесить шансы изменения первых и последних переменных

Версия 0.78 от 12.10.12
[*] Вычисления в выборке прерываются, если новое время ненамного хуже рекорда - константу надо подобрать, например 1.5 или 2
Возможно делать разную для разного расстояния Хэмминга. Для S = 1 худший вариант - 2 раза, т.е. добавили переменную, пространство 
увеличилось в 2 раза, а переменная ничего не дала. Для S = 2 это 4 раза, и т.д.
[*] Вместо deep_diff_decomp_set_count случайных векторов теперь генерируютс все вектора на заданном расстоянии Хэмминга.
	Генерируются блочно, по 100 точек. Если проверены все точки на расстоянии n, переходим к n+1.
[+] Исходники рассортированы по папкам
[*] Теперь можно начинать > 60 переменных, изменено вычисление среднего времени (pow() вместо shl64). 
	В этом случае в случайную выборку добавляются значения только из первых 2^60

Версия 0.75 от 14.09.12
[+] Добавлена имитация отжига. Начальная t = 5 % от времени в секундах прогноза в первой точке .
    Коэффициент умножения = 0.99. Останов по достижению min_temperature, которая для 72-порогового равна 20. 
[+] На расстоянии Хэмминга 1 генерируются все векторы (n штук). На бОльшем расстоянии генерируются deep_diff_decomp_set_count случайных векторов
[*] Из MPI_Predict() основные процедура по автоматическому прогнозированию вынесены в процедуру DeepPredictMain()

Версия 0.74 от 15.05.12
[+] Добавлен макрос _MPI, когда определен - тестирование в последовательном режиме
[*] Если core_len ну указано, по умолчанию оно равно 0 и стартовая активность не меняется
[*] poly_mod по умолчанию 0 -> -1 
[*] MAX_CORE_LEN изменен с 1024 на 128, т.к. для DeepPredict нужно часто создавать массивы var_choose_order
[*] Действия при прогнозировании на вычислительных процессах вынесены в функцию ComputeProcessPredict()
[*] Исправлен стиль в Makefile 
[+] Добавлена универсальная функция MakeRandArr() для генерации массива различных псевдослучайных чисел
[+] Добавлен вывод в файл однолитеральных дизъюнктов для самой долгой КНФ из выборки

Версия 0.73 от 18.04.11
[*] Исправлен последовательный режим Conseq для PB
[+] Добавлен ключ -check_every_conflict задающий в minisat2_solve частоту проверки наличия сообщений  
    об остановке с управляющего процесса. Добавлен параметр check_every_conflict в minisat2_solve, по умолчанию 2000.

Версия 0.72 от 05.04.11
[***] Исправлена критическая ошибка некорреткного прерывания minisa2.solve, приводящая к нахождению
	  неправильных опт. значений целевой функции
	  if ( conflict.size( ) == 0 ) ok = false
[+] Добавлен ключ "-exch_activ=" задающий интенсивность MPI обменов. Пока работает только для PB.
	0 - минимальная активность (для случая PB - на выч. процессы с управляющего не передаеются рекорды с других выч. процессов). 
	1 - средняя активность (по умолчанияю). В режиме PB на выч. процессы с управляющего передаются рекорды, полученые при завершении 
	работы над заданиями на других выч. процессах.
	2 - высокая активность. В режиме PB на выч. процессы с управляющего передаются не только рекорды по завершению работы над заданиями,
	но и все промежуточные рекорды (с итераций с добавлением неравенств) с каждого выч. процесса.
	В режиме PB с вычислительных процессов приходят сообщения со следующими значениями:
	1 - SAT задача на выч. процессе еще не решена, но найдено очередное приближение в итеративной процедуре,
		оптавляется найденное приближение
	2 - SAT задача на выч. процессе решена, ответ UNSAT (не найдено значение, лучшее, чем было передано на выч. проц.)
	3 - SAT задача на выч. процессе решена, ответ SAT (найдено значение, лучшее, чем было передано на выч. проц.)
[+] В dminsat добавлено срабатывание solver_lit_removable (так было в оригинальном minisat 1.14.1) в случае, если задача
	сложная (для долгих задач эта процедура ускоряет процесс решение). Задача считается сложной ( IsHardProblem == 1 ), 
	если 2^[число переменных распараллеливания]<= 2^[число ядер в системе].
[*] Дополнительные переменные внесены в структуру solver_t: IsPredict, core_len, corevars_activ_type, IsHardProblem
[+] Добавлен режим решения - MPI_ConseqSolve, в котором из текущей папки считываеются все файлы с
	расширением .cnf и для каждого запускается последовательное решение (full_mask = 0) на отдельном процессе.
[*] Подготовка к доблавению minisat2.2. Все служебные headers (типа SolverTypes.h) minisat2 и dminisat, а также
	headers, нужные для windows (pstdint, dirent) убраны в отдельные папки.
[*] Исправлена ошибка с невыводом выполняющего набора в файл output
[+] При IsHardProblem == 1 в dminisat отключено увеличение активности ядровых, т.к. для последовательного решения 
	порогового 72 битного это дает ускорение
[*] Исправлена ошибка с очисткой памяти. В main создание mpi_p перенесено после Conseq. Также в main теперь создается или mpi_p 
	или mpi_s.
[+] В ReadIntCNF для PB добавлен разбор "c input variables [N]", ранее разбирался только случай "c [N] input variables".
	Добавлен разбор "c object variables %d"  вместе с "c %d obj var". Добавлен разбор инфы, в которой не указаны constraints clauses
	и object clauses (В первом прилбижении ищем вып. набор для всей КНФ). Изменены sscanf на работу с stringstream.
 ***---*** Если режим PB, то принудительно включается solver_type = 3. Надо поменять при добавлении minisat2.2
[+] В MPI_ConseqSolve добавлена работа с псевдобулевыми задачами
[+] В ControlProcessMessagesPB_ineq сделано построение values_arr - допустимых значений для задачи QAP. В каждой строке только одна 1,
	индексы единичных значений не должны совпадать.

Версия 0.71 от 06.02.11
[*] Исправлена ошибка отправки сообщений при extra_tasks (ошибка сделана после версии 0.67, full_mask_ext
	нужно передавать как массив arr[LEN] а не как *arr)
[+] Добавлены aсинхронные обмены - когда улучшается рекорд значения целевой функции на упраляющем процессе,
    он отсылает это значение на все вычислительные. в асинхронном режиме эти сообщения принимаются вычислительными,
    если текущее значение рекорда целевой функции на вычилсительном процессе больше, чем присланное, работа SAT-решателя
    досрочно завершается, выход на уровень итераций псеводобулева решателя, добавление нового неравенства c значением,
    полученым с управляющего процесса.
[*] Исправлена ошибка в режмие PB, возникающая, когда приближение, найденое на препроцессинге 
	(разбор только ограничений) совпадает с оптимальным значением.
[+] Добавлен режим ineq_value, распараллеливание по интервалу возможных значений целевой функции 
[*] Исправлена ошибка в PB_ineq
[*] В SolverTypes.h описание функции friend Clause_new вынесена из класса Clause т.к. 
    новая версия компилятора на Blackford выдает ошибку "не обяъвлено Clause_new".
[*] Переход от char* к string и stringstream, т.к. новый компилятор на Blackford выдавал ошибку
	"не объявлены strlen и strcpy"
[*] Исправлена ошибка в схеме № 10 (9+9+11) в MakeVarChoose( )
[*] В ReadIntCNF добавлена проверка ( line_str.find( "input variables" ) == 6 ) в разбор строки
	c %d input variables т.к. sscanf не сравнивал строки дальше %d
[+] Добавлен тестовый режим TestPBSolve

Версия 0.70 от 19.12.10
[+] Добавлен новый псевдобулевый режим - распараллеливание по равенствам.
	Активируется, если есть ключи - blb и ub. blb - лучшая известная граница, непроверенное значение. 
	ub - лучшая верхняя граница, проверенное значиение. Создается ( ub - blb ) задач с явным ограничением 
	типа равенства на целевую функцию. Если blb = ub, то создается 1 задача, проверить blb.
	Решаются попеременно задачи с начала и с конца, чтобы сперва обработать простые задачи.
[+] Добавлен m2_orig для режима PB_mode == 2, с равенствами

Версия 0.69 от 14.12.10
[+] Сделано 2 режима - CNF и PB. В класс MPI_Solver добавлена процедура ControlProcessSolve, 
	в которую вынесены MPI обмены управляющего процесса в режиме CNF
[+] В ReadIntCNF добавлен разбор данных о PB задаче - строк виде "c constraint clauses [n]",
	"object clauses [k]", "obj vars [ind1] [ind2] ...". Если в строках введены корректные данные,
	то автоматически включается режим PB.
[*] Формирование b_SAT_set_array перенесено в ReadIntCHF
[+] Добавлен параметр -pb. Если задан, в MPI_Solve перед ReadIntCNF с помощью Transalg формируется файл с КНФ,
[+] В класс MPI_Solver добавлены процедуры ControlProcessMessagesPB, ComputeProcessSolve, ComputeProcessMessagesPB
[*] В ConstrClausesToProblem учтено, что в minisat литералы начинаются с 0, а в clause_array - с 2
[+] В ресурсы добавлена тестовая система ЦЛП 
	имя которого записывается в input_cnf_file. Далее на выч. процессах запускается pb_solver, 
	в котором в процессе решения используется итеративный поиск минимума целевой функции.

Версия 0.68 от 25.11.10
[**] Исправлена ошибка с формированием extra_tasks_count. Теперь если число заданий более чем в 2 раза
	 меньше, чем число выч. ядер, то extra_tasks_count не добавляются (т.к. пользователь сам этого не хочет).
	 Из-за ошибки не работал режим MP_Solve с full_mask_var_count = 0 (решение задачи без распараллеливания)
[+] В ReadIntCNF добавлено считывание числа входных переменных из КНФ в строке "c [x] input variables"
	Если такой строки нет и core_len не задается явно входным параметром, то core_len = var_count
[+] Добавлена стратегия формирования декомпозиционного множества Literal Count
[+] Добавлена стратегия формирования декомпозиционного множества Jeroslaw-Wang
[+] Добавлена стратегия формирования декомпозиционного множества Implicant Count
[*] Процедура ReadIntCNF убрана из AnalyzeSATset в начало процедур MPI_Solve и 
	MPI_Predict (т.е. это делает каждый процесс), т.к. 
	1) управляющий процесс - массивы с литералами нужны для эвристик Literal_Count и т.п. на этапе подготовки заданий
	2) вычислительные процессы - нужно запускать AnalyzeSATset
[+] В ресурсы добавлена тестовая КНФ
[*] Изменены процедуры ReadVerCount и ReadInt. Теперь длиные двумерные массивы clause_array и lits_clauses_array
	считываются заранее и точно (раньше была константа MAX_LITS и т.п.)
[+] Добавлено ограничение на core_len = 1024, т.к. пока с бОльшим числом переменных маски работать не будет 
	Так что весовые эвристики типа Literal count для больших КНФ выбирают только из первых 1024 переменных входа
[+] Добавлен вывод SAT или UNSAT в файл output
[*] Значение core_len по умолчанию изменено с 64 на 0. В ReadIntCNF если core_len == 0, то core_len = var_count;

Версия 0.67 от 02.09.10
[+] Добавлен учет ситуации "число вычислительных процессов > 2^[число переменных разбиения]"
	Например при распараллеливании по 6 переменным на 80 ядрах 15 КНФ из 64 можно разделить 
	еще на 2 КНФ каждую, т.е. будет 49 КНФ с подстановкой 6 переменных и 30 КНФ с подстановкой 
	7 переменных. На основе полученного старнартным образом full_mask (в этом случае full_mask и 
	part_mask равны) делаются модификация full_mask_ext. При этом full_mask_ext[2] = full_mask[2] 
	с добавленной "1" в маску (аналогично для part_mask_ext, в примере full_mask[2] = 111111, 
	full_mask_ext[2] = 1111111) Для этого добавлена функция GetExtraTasks, в которой временно 
	увеличивается full_mask_var_count, чтобы получить full_mask_ext, эта маска (и модифицированные 
	с ее помощью часть значений values_arr) передаются в последних в очереди заданиях
	(в примере = первые 49 получают full_mask, оставшиеся 30 получают full_mask_ext).
	При этом 15 элементов values_arr не меняются (49..63), так как full_mask_ext и так указывает, что
	нужно рассматривать их "0" как значение value. Для последних 15 (64..78) на месте этого "0" будет стоять "1",
	в итоге и достигается распараллеливание по дополнительной переменной для 15 из 64 заданий
[*] Функция GetIntValuesForMinisat заменена на MakeStandartMasks, которая разбита на 3: MakeVarChoose,
	GetMainMasksFromVarChoose, GetValuesFromVarChoose
[*] Для простоты и совместимости с переменными цикла типы некоторых глобальных переменных изменены с unsigned int 
	на int, там где не нужны большие значения

Версия 0.66 от 23.03.10
[+] Добавлены схемы формирования "последние в РСЛОС, которые определяют выход" для суммирующего и порогового
[+] Добавлены схемы формирования "1 целый РСЛОС + оставшиеся последние в РСЛОС" для суммирующего и порогового
[+] Добавлен флаг -activ, задающий тип изменения активности ядровых переменных
	= 0 - по умолчанию, от 1 до последней ядровой переменной
	= 1 - равные значения (=1) у всех ядровых переменных
[*] Значение по умолчанию proc_count изменено с 128 на 127, чтобы запускать не на 129 процессах (запускалось на 136),
	а на 128. Для прогнозирования Гиффорда нужно указывать явно -proc=128, запускать на 129 процессах как и раньше
[*] Значение corevars_activ_type по умолчанию изменено с 0 на 1
[*] Тип corevars_activ_type изменен с int на double, для поиска лучшей начальной активности
[*] Изменены схемы формирования 20-30 (суммирующий, пороговый) с "последние в РСЛОС" на "первые в РСЛОС",
	т.к. эффект тот же (первые дойдут до конца), но так дольше обозначаенные переменные "на плаву"
[*] Убраны дублирующие проверки при работе с corevars_activ в dminisat_solve и minisat2_solve
[*] В проекте и makefile p-sat заменено на pd-sat
[+] Добавлена схема № 5 в массовое прогнозирование, для a5/2 (4 блока, 19 + 22 + 23 + 17 = 81)

Версия 0.65 от 27.02.10
[***] Исправлена критическая ошибка в GetRandomValuesArray, создавался values_arr с одинаковыми значениями
[***] Исправлена критическая ошибка в MassPredict, не очищался массив var_choose_order
[+] Добавлен режим mass_predict для прогнозирования с варьированием по блокам.
	Для Гиффорда 8 блоков по 8 бит, для генераторов на основе РСЛОС блок = РСЛОС
[+] В MPI_Base добавлена процедура GetValuesFromVarChoose для формирования 
	part_mask, full_mask и values_arr по массиву var_order_choose
[*] Исправлена ошибка с необнулением full_mask и part_mask в начале процедуры GetValuesFromVarChoose
[-] Убрано обнулением full_mask и part_mask в GetIntValuesForMinisat (перенесенго в GetValuesFromVarChoose)
[*] Испрвлены обшибки с несоответствием типов predict_from predict_to и proc_count в main и mpi_base
[-] Убрано обязательное условие на наличие proc_count для запуска MPI_Predict
[+] Добавлен вывод информации по Mass_predict в WritePredictToFile
[+] В класс mpi_base добавлена процедура SortValuesDecrease, сортирующая массив значений по убыванию единиц
	Процедура нужна для MassPredict, чтобы сначала шли значения по всем блокам, потом по убыванию числа блоков
[*] Внесены изменения в GetPredict для работы MassPredict 
	(вычисление cur_var_num, учет того, что для MassPredict номер decomp_set_count 
	не соответствует числу переменных распараллеливания)
[+] Добавлен массив sum_block_lens_arr, содержащий количество переменных для распараллеливания
	в случае MassPredict
[*] Модифицирована shl64, чтобы выдавать максимум степень не 2^60, а 2^62
[*] Все long long int изменены на unsigned long long int
[*] Изменено построение пороговой функции для MassPredict
[+] Добавлено отсечение наборов с большим числом переменных в MassPredict (больше 48 переменных)
[-] Убран вывод nassigns в dmimisat и minisat2
[*] MAX_PREDICT_TO изменен с 48 на 40
[+] В GetPredict добавлен учет ситуации, когда все SAT-задачи из выборки были решены,
	но время получилось хуже (т.е. надо прерывать, а прерывать нечего). Статус выборке
	все равно ставится 1. Проблема с удвоением cur_cnf_solved_count (2 раза учитывались UNSAT КНФ)
	решена путем присвоения cur_cnf_solved_count = 0 перед процедурой остановки
[*] В GetPredict исправлено формирование polynom_val_arr
[+] Добавлены новые схемы массового прогнозирования (пороговый 72 и 80 бит, сум 63 бита)
[+] Добавлена сортировка в GetMassPredict, чтобы учитывать, что блоки могут быть разной длины,
	и нужна дополнительная сортировка внутри множества с одинаковым числом блоков 
	(вместо 11 13 15 -> 15 13 11), по убыванию числа переменных
[+] Добавлен FIRST_PREDICT_EVERY_SEC = 6, во время которого нет прогноза, 
	чтобы не обрывались вычисления в начальных точках
	(временно, вообще на управляющем разделить на 2 потока - 1 диспетчерский, 2-ой прогнозный (и обрывающий))
[*] Исправлена ошибка в MPI_Base::shl64(). Неправильно обрабатывались числа больше 30
[-] В GetIntValuesForMinisat убраны схемы формирования с № 41 по № 56, старая реализация
	частных схем массового прогнозирования для суммирующего генератора

Версия 0.64 от 18.01.10 -- Основа - рабочая версия 0.62, постепенные изменения из 0.63
[*] Исправлена ошибка в dminisat с назначением литералов в assigns
[+] Добавлено удаление массивов в ~MPI_Predict
[*] Исправлена ошибка - не обнулялись значения value_arr перед назначением случайных значений в PrepearePredict( )

Версия 0.63 от 15.01.10 -- НЕРАБОЧАЯ ВЕРСИЯ -- глючит dminisat_solve и minisat2_solve
[*] Изменена процедура GetIntValuesForMinisat
[*] Изменен формат передаваемых масок. Теперь передается массив из 34 unsigned int.
     0-ой элемент - число ненулевых значений 2..33 подряд. 1-ый элемент - маска 32-ух элементов,
     2..33-ый элементы - маски значений 
[-] Временно убрана сортировка
[*] Исправлена ошибка. core_len по умолчанию принимал занчение 0, а нужно было 64

Версия 0.62 от 20.12.09
[*] В режиме прогнозирования вdminisat и  minisat2 исправлено формирование 
    реального времени счета SAT-задач на вычислительных процессах. 
    Первая метка теперь ставится не до процедуры parse_DIMACS, а после, 
    перед solver_solve. Вторая - после solver_solve.
[*] В mpi_predicter.cpp исправленно вызов SAT-решателя в зависимости от значения 
	solver_type. Сделано как в mpi_solver.cpp в версии 0.61;
[+] Добавлены актуальные пояснения в WriteUsage( )
[*] Исправлено формирование прогнозных данных для var_num > 30
[+] Доавблен вывод новых данных в WritePredictToFile
[*] Как в версии 0.39, в minisat2_solve() simplify вынесено перед циклом,
	в случае полного упрощения КНФ (КНФ обрабатывать не надо) 
	выполняющий набор не выводится (т.к. S.model остается пустой)
[*] Внесены изменения, позволяющие rang_val_count быть > 2^31
[+] Добавлен вывод минимального и максимального времени в случайной выборке

Версия 0.61 от 12.12.09
[+] Добавлен класс MPI_Solver
[+] В Makefile добавлена компоновка mpi_solver.o и mpi_predicter.o
[+] Добавлен ключ -core_len, задающий количество ядровы переменных в КНФ
[+] В dminisat добавлен учет core_len при увеличении активности 
[+] Добавлено повышение активности для minisat2_mod
[-] Убрана работа с full_mask_2. В дальнейшем нужно использовать структуру для передачи
	масок 
[*] В MPI_Solve full_mask и part_mask передаются теперь только 1 раз в каждый процесс
[+] Добавлены прототипы функции в p-sat.cpp
[+] Добавлен класс MPI_Predicter
[+] Добавлен класс MPI_Vase, от него наследованы MPI_Predicter и MPI_Solver
[*] Значение poly_mod сделано по умолчанию = 0
[*] Исправлена ошибка - менялась активность переменных при solver_type == 2,
	хотя это оригинальный minisat2
[+] Добавлен новый ключ cnf_in_set_count, задающий число КНФ в случайной выборке

Версия 0.60 от 25.11.09
[+] Добавлен -s=m2_orig для оригинального minisat2
[-] Убран SAT-решатель dminisat2 (нестабильный, не используется)  
[*] Обновлен WriteUsage 
[*] Исправлена ошибка "Если -schema указано раньше -s возможна ошибка с определением schema_type 
    (переназначается в разборе ключа -s)"
[*] CHECK_EVERY_NOCONFL изменен с 1000 на 2000
[+] Добавлен разбор значения poly_mod == 2 (так же с полиномом, как при poly_mod == 1, но с назначением улучшения
	текущего прогнозного на основании не всех посчитанных SAT-задач из выборки)
[*] Добавлена передача параметра koef_val в GetPredict для расчета транспортных расходов
[*] Число КНФ в выборке (cnf_in_set_count) изменено с corecount на (corecount - 1)

Версия 0.59 от 20.11.09
[**] Исправлена ошибка в ReadIntCNF, процедура переписана заново в C++
[**] Исправлена ошибка при вызове GetInValuesForMinisat для full_mask_var_count == 0
[+] Добавлена процедура преыванию по достижению прогноза текущего наилучшего
[+] Добавлен ключ -poly_mod определяющий вид полинома прерывания
	-poly_mod=0 - по достижению прогноза
	-poly_mod=1 - по рекуррентному полиному
[*] Инициальное значение элементов массива polynom_val_arr изменено с 0 на 1000, чтобы ничего не прервать
	до первого явного изменения polynom_val_arr(первый status=2 выборки)  
[*] PREDICT_EVERY_SEC изменен с 1 на 2 секунды
[*] Изменены константы minisat2 на var_decay(1 / 0.95), clause_decay(1 / 1), random_var_freq(0.0) 
[+] Добавлена проверка на наличия завершающего 0 в дизъюнкте при считывании КНФ из файла
[*] В MPI_Abort( ) изменен код ошибки с 10 на 0
[*] Подправлена обработка некорректных строк в КНФ в ReadVarCount
[+] Добавлен вывод выполняющего набора в файл answer_[имя КНФ] в формате zchaff
[*] Изменено формирование имени файла answer_[имя КНФ], чтобы пропустить символы разделения папок
[*] При формировании числа заданий теперь учитиываются только вычислительные ядра,
	т.е. для corecount == 129 при коэффициенте 4 будет 4*128 заданий, а не 4*256
[+] Добавлена возможность расчета КНФ без распараллеливания - MPI_Solve по 0 переменным

Версия 0.58 от 10.11.09
[+] Добавлено периодическое вычисление GetPredict через временной интервал
[+] Добавлена возможность задания полинома дробной степени
[+] Добавлен ключ -pred_power, задающий степень полинома при прогнозировании
[+] Добавлено прерывание счета в minisat2, в Solver :: search 
[-] Убран учет TRANSP_OTHER_CNF_PREDICT
[*] PREDICT_EVERY_SEC изменен с 2 на 1 секунду, CHECK_EVERY_NOCONFL изменен с 1708 на 1000

Версия 0.57 от 08.11.09
[**] Исправлена критическая ошибка. В версии 0.56 в циуле обнулялась переменная cnf_to_stop_count,
	 из-за чего не происходила отправка стоп-сообщений.
[**] Исправлена ошибка - при малых значениях времени прогноз в правой границе больше, чем должен быть, 
	 из-за накладных расходов при отправлении первой первой серии заданий. Исправлено с помощью 
	 массива реального времени
[+] Добавлена проверка на наличие стоп-сообщений внутри SAT-решателя,
	примерно через каждые 1700 конфликтов (это около секунды )
[+] Добавлено вычисление полинома и сравнение с ним
[-] Убрано отправление full_mask в режиме прогнозирования, т.к. его значение
	всегда равно part_mask
[+] Добавлен массив реального времени счета заданий на вычислительных узлах
[+] Добавлен вывод пронгозной информации в файл после каждого срабатывания GetPredict()
[*] Вывод информации о прогнозировании в файл сделан читабельнее
[*] proc_count теперь берется из ключа. если ключ не задан, берется по умолчанию = 128
[*] cnf_in_set_count теперь снова берется = corecount. Нужно для корректного счета первых 
	corecount КНФ
[+] Добавлен коэффициент TRANSP_OTHER_CNF_PREDICT, чтобы обработка выборки не закончилась раньше времени
	из-за погрешности приблизительного времени
[*] Подчищена процедура GetPredict, чтобы не выполнялись лишние действия

Версия 0.56 от 28.10.09
[**] Исправлена ошибка с неназначением статуса SAT выборке, если в ней кроме SAT КНФ есть и UNSAT
[**] Исправлена ошибка в MPI_Solve
[**] Исправлена ошибка с числом отрешенных SAT-задач в выборке
[**] Исправлена ошибка в Analyzer. Были по ошибке убраны нужные { }
[+] Добавлен вывод результатов прогнозирования в файл
[*] Переписаны процедуры считывания файла с КНФ (string вместо char*)
	Число переменных и дизъюнктов теперь считывается из дизъюнктов
[*] В dminisat_solve и minisat2_solve добавлена проверка режима работы,
	чтобы не запускать MPI_Probe в режмие MPI_Solve
[*] Работа dminisat_solve сделана кросплатформенный. Не работал под Windows
	случай, когда SAT-задачу надо было решать (если вывод на препроцессинге, все работало)
[*] Расширен диапазон прогнозирования - теперь [0..60]
[*] Изменен подсчет транспортных расходов - вместо подсчета времени на КНФ, считается время на 1 пакет с заданием

Версия 0.55 от 23.10.09
[+] Добавлено прерывание решения SAT-задач по выборке
[*] Исправлена ошибка с MPI_Irecv. Сделано через MPI_IProbe

Версия 0.54 от 19.10.09
[+] В MPI_Predict сделан сбор в массив информации о времени обработки КНФ из случайных выборок
[+] Сделан вывод информации о прогнознои времени

Версия 0.53 от 06.10.09
[*] Исправлена ошибка в схеме 10 - при full_mask_var_count < 10 full_mask получалось = 0
[*] Тестирование убрано в отдельную процедуру Test
[*] Добавлено #pragma warning(disable:4996) чтобы не показывались ошибки VS про старые функции типа
	sprintf или strncopy (VS 2008 предлагает заменить их на новые безопасные аналоги, но тогда теряется платформонезваисимость)
[+] Добавлена схема формирования № 21. Выбираются 17 переменных управляющего регистра, затем с начала 2 регистра до его конца
[+] Добавлена схема формирования № 22. Выбираются 17 переменных управляющего регистра, затем с конца 1 регистра до его начала
[+] Добавлена схема формирования № 23. Выбираются 8 переменных управляющего регистра, затем с начала 1 регистра
[*] Исправлена ошибка отправки заданий в случае, если part_mask и part_mask_2 не пустые
[*] Исправлена ошибка в dminisat_solve c обработкой списка SAT-задач
[*] Разбор схем формирования объединен для всех видов SAT-решателей
[+] Добавлена работа с m2(можно варьировать по 128 переменным) для схемы "full_mask + full_mask_2"

Версия 0.52 от 28.09.09
[+] Добавлена схема формирования № 20 - для А5/2. Сначала выбираются 17 переменных
	управляющего регистра, потом начиная с 0-ой (начало 1-го регистра)

Версия 0.51 от 27.09.09
[*] Выдающий отрицательные значения clock заменен на MPI_Wtime

Версия 0.50 от 24.09.09
[+] Доавблен разбор ключей для прогнозирования -from -to -proc
[+] Добавлен вызов процедуры MPI_Predict (если указаны -from -to -proc)

Версия 0.49 от 14.09.09
[*] Параллельное решение (MPI_Solve) вынесено в одтельную процедуру
[*] Исправлена ошибка неназначения schema_type при отсутствии -solver и -schema
[+] Добавлен вывод значения schema_type в выходной файл
[+] Добавлена проверка на то, что corecount >= 2

Версия 0.48 от 13.09.09
[+] Добавлен разбор значения ключа -schema для dm и dm2

Версия 0.47 от 03.09.09
[+] Начато добавление режима прогнозирования
[*] Исправлена критичная ошибка в minisat2
Неправильно добавлялись литералы в assigns - через toLit( j + 1 )
Правильно - через Lit( j )

Версия 0.46 от 28.08.09
[+] Добавлен разбор ключа -s (идентичен ключу -solver)
[+] Добавлен ключ -schema, в нем возможное варианты:
	first        - 1, 2, 3, ...
	missone      - 1, 3, 5, ...
	firstandlast - 1, 56, 2, 55, ...

Версия 0.45 от 23.08.09
[+] В WriteUsage добавлены комментарии о работе с ключами -koef и -sort
[*] Временно сделана рабочая старая версия работы с m2

Версия 0.44 от 20.07.09
[*] Убраны printf в режиме m2

Версия 0.43 от 18.07.09
[*] Исправлена ошибка при числе переменных разбиения < 11 
[*] Исправлена ошибка освобождения памяти в процедуре SortValues (вызывается при сортировке 2 уровня)

Версия 0.42 от 16.07.09
[+] Добавлена сортировка 2-го уровня (в dminisat)
[*] Убраны warnings о несоответствиях int-типов

Версия 0.41 от 15.07.09
[+] Добавлена процедура умного разбора входных флагов 
[+] Добавлен флаг sort, процедура Sort зависит от значение флага sort
[+] Добавлен флаг koef - значение коэффициента koef_val
[*] Флаг -s изменен на -solver

Версия 0.40 от 12.07.09
[+] Добавлена сортировка элементов массива values_arr

Версия 0.39 от 08.07.09
--- РАБОЧАЯ ВЕРСИЯ ---
[-] В minisat2_solve() убрано копировние объекта S в S_temp, 
решается как и раньше S на каждой итерации, с очисткой learnts
[*] В minisat2_solve() simplify вынесено перед циклом,
в случае полного упрощения КНФ (КНФ обрабатывать не надо) 
выполняющий набор не выводится (т.к. S.model остается пустой)

Версия 0.38 от 07.07.09
--- НЕРАБОЧАЯ ВЕРСИЯ ---
Ошибка в деструкторе экземпляров класса Solver
[*] Изменена схема работы в minisat2 на копирование объекта S в S_temp перед каждым счетом,
т.к. cleardb( ) не очищала S полностью после solve( )
[+] Добавлена проверка наличия дизъюнктов после Simplify( )

Версия 0.37 от 04.06.09
[*] Исправлена утечка памяти - не очищались данные объекта S после окончания работы minisat2_solve

Версия 0.36 от 03.06.09
[*] Исправлены часть warnings и Makefile

Версия 0.35 от 29.05.09
[*] Исправлена ошибка формирования негативного литерала в minisat2
Из-за нее в КНФ добавлялось только примерно половина однолитеральных дизъюнктов,
из-за решалось дольше, чем должно было.
[*] Исправлена ошибка невызова solver_cleardb( s ) в версии dminisat с fork
[*] Вызов dminisat2 оставлен только если не определен _MSC_VER

Версия 0.34 от 27.05.09
[+] Встроен dminisat2

Версия 0.33 от 25.05.09
[*] Исправлена ошибка универсального заполнения массива значений частичной маски
[*] Исправлено формирование частичной маски в случае, если число заданий 
меньше числа ядер

Версия 0.32 от 23.05.09
[*] Исправлена ошибка формирования full_mask в случае full_mask_var_count < 22
[+] Добавлена новая схема формирования - первые подряд

Версия 0.31 от 21.05.09
[+] Добавлена новый входной параметр [тип SAT-решателя].
Пока 2 варианта - dm и m2, для dminisat и minisat2 соответственно.

Версия 0.30 от 20.05.09
[+] Добавлена функция minisat2_solver
[*] Для избежания конфликтов функция toLit() в dminisat
переименована в toLitdminisat() 

Версия 0.29 от 18.05.09
[+] Формат вывода времени выполнения в файл output имзенен с
    [секунды] на [часы] [минуты] [секунды]

Версия 0.28 от 17.05.09
[+] Добавлен вывод времени выполнения в файл output

Версия 0.27 от 14.05.09
[+] Добавлен вывод выполняющего набора в файл output

Версия 0.26 от 14.05.09
[+] Добавлено получение выполнящего набора из dminisat_solve

Версия 0.25 от 14.05.09
[+] Добавлены исходники dminisat
[*] Вызов dminisat изменен с system(...) на явный вызов процедуры
[*] Изменен Makefile
[*] Изменен Parallel-SAT.cpp на p-sat.cpp

Версия 0.24 от 29.04.09
[+] Добавлен вызов MPI_Finalize( ) перед каждым высзовом return 1 в main

Версия 0.23 от 28.04.09
[*] Изменено формируемое число заданий с [число выч. единиц] на 8*[число выч. единиц] 
[*] Изменен вид рассылки на динамический

Версия 0.22 от 21.04.09
[+] Добавлено удаление нулевых res-файлов по нахождению выполняющего набора
[*] Стилистические улучшения
[-] Убран входной параметр [шаблон для res-файдлов]. Теперь берется по умолчанию = "./res"
[*] Параметр [Число переменных для распараллеливания] сделан необязательным

Версия 0.21 от 16.04.09
[*] Предел возможного числа ядер увеличен с 2^11 до 2^22

Версия 0.20 от 15.04.09
[-] Убран параметр [число подставляемых переменных]. Это число вычисляется автоматически 
на основании [число ядер параллельной системы]

Версия 0.19 от 18.03.09
[+] Добавлена автоматическая проверка res-файлов на наличие выполняющего набора
[*] MPI_Abort( ) вызывается телько после нахождения выполняющего набора

Версия 0.18 от 16.03.09
[+] Добавлена команда MPI_Abort после завершения первого процесса - 
завершаются все остальные процессы в группе
[*] Изменен формат строки-системной команды - > ./res выведено в конец строки

Версия 0.17 от 13.03.09
[*] Убраны утечки памяти (new -> delete)

Версия 0.16 от 12.03.09
[*] Статичесеие параметры (путь к файлу SAT-решателя, путь к файлам 
с результатами) вынесены во входные параметры

